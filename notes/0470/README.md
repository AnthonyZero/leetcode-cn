## 470.用 Rand7() 实现 Rand10()

### 题目描述
已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

示例 1:
```
输入: 1
输出: [7]
```

示例 2:
```
输入: 2
输出: [8,4]
```
示例 3:
```
输入: 3
输出: [8,1,10]
```

提示:

* rand7 已定义。
* 传入参数: n 表示 rand10 的调用次数。

进阶:

* rand7()调用次数的 期望值 是多少 ?
* 你能否尽量少调用 rand7() ?


### 思路
拒绝采样： 如果题目给的是rand10()，让你生成 1～7之间的某个数，那非常好办，我们只要不断调用 rand10()即可，直到得到我们要的数，而且是等概率的。
     
现在要从 rand7() 到 rand10()，也要求是等概率的，那只要我们把小的数映射到一个大的数就好办了。我们不能直接rand7() * rand7()，因为这样是得不到一些数的，比如一些质数（11,13等等 两个数的乘积得不到）。 首先 rand7()-1得到的数的集合为{0,1,2,3,4,5,6}，再乘 7 后得到的集合A为{0，7，14，21，28，35，42}，
这A集合一共7个数，最后 rand7()得到的集合B为 {1,2,3,4,5,6,7} 与A集合相加 可以得到[1,49]的集合，且是等概率的，因为A和B集合事件是独立的。

最后我们的函数会得到 1～49之间的数，直接不断while得到1~10返回即可。

上面可以优化的点在：我们只想得到 1～10 之间的数，这一部分占的比例太少了，简而言之，这样效率太低，太慢，可能要 while循环很多次，那么解决思路就是舍弃一部分数，只舍弃 41～49，因为是独立事件，我们生成的 1～40 之间的数它是等概率的，我们最后完全可以利用 1～40之间的数取余 + 1来得到 1～10 之间的数

> 已知 rand_N() 可以等概率的生成[1, N]范围的随机数
  那么：(rand_X() - 1) × Y + rand_Y() ==> 可以等概率的生成[1, X * Y]范围的随机数 即实现了rand_XY()
```   
    //优化 只丢弃[41,49] 用[1,40] 取余 + 1
    public int rand10() {
        int num = (rand7() - 1) * 7 + rand7(); //rand49 [1,49]
        while (num > 40) {
            num = (rand7() - 1) * 7 + rand7();
        }
        return num % 10 + 1;  //[1,10]
    }

    // [1到7]
    public int rand7() {
        return (int)(Math.random()* 7) + 1;
    }
```

### 扩展
已有函数Rand11()可以返回[0-10](左右闭区间)的随机数，请基于这个函数写一个函数Rand100()，要求Rand100()可以返回[0-99](左右闭区间)的随机数(尽最大可能随机)。
```   
    int Rand100()
    {
        int result = 0;
        do {
            result = Rand11() * 11 + Rand11()
        } while(result > 99) ;
        return result;
    }
```   

