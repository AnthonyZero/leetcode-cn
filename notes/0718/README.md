## 718. 最长重复子数组

### 题目描述
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例 1:
```
输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。
```


### 思路
和最长公共子序列问题不同的地方在于：子序列不需要连续，而此时的问题时 最长公共子串（子数组）需要连续

最长公共子序列dp[i][j]即是结果，而最长公共子串 需要看所有的dp结果 找到最大值才是最终结果
（需要设置一个maxLength，每一步递推的时候都更新得到最长公共子串的长度）

根据我们的dp的定义：比如A = [3,2,1] B=[1,2]

dp[3][2] 看末尾字符 A[2] != B[1] 就是 3,2,1以1结尾 1,2以2结尾的 公共字串长度为0
（为什么是0呢，这里不是有2吗，因为我们的定义是结尾要包含判断进去 连续的字符，所以结尾不相同 直接为0）

而往前看dp[2][2] 此时3,2 和1,2 结尾相同；那么就等于dp[2-1][2-1] + 1; 
dp[1][1]显然为0 那么dp[2][2] = 1.

通过看到所有的dp值 得出两个字符串的 最长公共子串长度在 dp[2][2]的长度值或者dp[3][1]的长度值
```   
    public int findLength(int[] A, int[] B) {
        //dp[i][j]代表以A[i-1]与B[j-1]结尾的公共字串的长度,公共字串必须以A[i-1]，B[j-1]结束
        //即当A[i-1] == B[j-1]时，dp[i][j] = dp[i-1][j-1] + 1;
        // 当A[i-1] != B[j-1]时，以A[i-1]和B[j-1]结尾的公共字串长度为0,dp[i][j] = 0。（此时包含了A[i-1] B[j-1] 因为子串必须连续 不相等直接为0）
        int[][] dp = new int[A.length + 1][B.length + 1]; //第一行 第一列不用 都是0
        //结果maxLength的值 就是找dp数组中最大的值 返回
        int maxLength = 0;
        //递推
        for(int i = 1; i <= A.length; i++) {
            for(int j = 1; j <= B.length; j++) {
                if(A[i - 1] != B[j - 1]) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j - 1] + 1; //
                }
                maxLength = Integer.max(maxLength, dp[i][j]);
            }
        }
        return maxLength;
    }
```

