## 1038. 从二叉搜索树到更大和树

### 题目描述
给出二叉搜索树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

* 节点的左子树仅包含键小于节点键的节点。
* 节点的右子树仅包含键大于节点键的节点。
* 左右子树也必须是二叉搜索树。


示例:
![二叉搜索树](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

提示：
1. 树中的节点数介于 1 和 100 之间。
2. 每个节点的值介于 0 和 100 之间。
3. 给定的树为二叉搜索树。


### 思路
本题是说修改每个节点的值等于原树中大于或等于该节点val 的值之和。从给的示例上来看节点8没有比它大的节点，那么8这个节点
改变之后值还是8。7这个节点大于等于7的数字有7和8，所以节点7的值更新为7+8=15；......；以此类推

最后各节点修改前和修改后对应值应该有：

[0,  1,  2,  3,  4,  5,  6,  7,  8]

[36, 36, 35, 33, 30, 26, 21, 15, 8]

相当于从8开始遍历到0，每一项修改为当前值 + 前面之和。 8 = 8+0；15 = 7+8； 21 = 6+15；
而我们知道二分搜索树的中序遍历是它的从小到大的排序顺序。那么这我们从8遍历到0（相当于反向的中序遍历：右子树-》当前节点-》左之树）同步修改值就可以了。
```   
    private int preValue = 0; //前一个值
    public TreeNode bstToGst(TreeNode root) {
        if (root == null) {
            return null;
        }
        bstToGst(root.right);
        root.val = root.val + preValue; //赋予新值
        preValue = root.val; //更新下一个节点 要加的值
        bstToGst(root.left);
        return root;
    }    
```

